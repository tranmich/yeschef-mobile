/**
 * ğŸ“± LOCAL DATA MANAGER
 * 
 * Unified local-first data management service for YesChef Mobile
 * Handles drafts, temp saves, auto-backup, and offline persistence
 * 
 * Features:
 * - Auto-save drafts with timestamps
 * - Backup system for data safety
 * - Cross-feature integration (Meal Plans â†” Grocery Lists)
 * - VS Code-style unsaved changes tracking
 * - App lifecycle management (save on exit)
 */

import AsyncStorage from '@react-native-async-storage/async-storage';
import { AppState } from 'react-native';

class LocalDataManager {
  
  constructor() {
    this.AUTO_SAVE_INTERVAL = 30000; // 30 seconds
    this.MAX_DRAFTS_PER_TYPE = 10; // Keep last 10 drafts
    this.autoSaveTimers = new Map();
    this.unsavedChanges = new Map();
    
    // Initialize app lifecycle listener
    this.initializeAppLifecycle();
  }

  // ==============================================
  // ğŸ”„ APP LIFECYCLE MANAGEMENT
  // ==============================================

  initializeAppLifecycle() {
    AppState.addEventListener('change', this.handleAppStateChange);
  }

  handleAppStateChange = (nextAppState) => {
    if (nextAppState === 'background' || nextAppState === 'inactive') {
      console.log('ğŸ“± App backgrounding - triggering auto-save');
      this.saveAllDraftsOnBackground();
    }
  }

  async saveAllDraftsOnBackground() {
    try {
      // Get all active unsaved changes and save them
      const savePromises = [];
      
      for (const [key, hasChanges] of this.unsavedChanges) {
        if (hasChanges) {
          const [type] = key.split('_');
          if (type === 'mealPlan') {
            savePromises.push(this.triggerMealPlanAutoSave(key));
          } else if (type === 'groceryList') {
            savePromises.push(this.triggerGroceryListAutoSave(key));
          }
        }
      }
      
      await Promise.all(savePromises);
      console.log('âœ… Background auto-save completed');
    } catch (error) {
      console.error('âŒ Background auto-save failed:', error);
    }
  }

  // ==============================================
  // ğŸ“‹ MEAL PLAN DRAFT MANAGEMENT
  // ==============================================

  /**
   * Save a meal plan draft with timestamp
   */
  async saveMealPlanDraft(mealPlanData, draftName = null, options = {}) {
    try {
      const timestamp = Date.now();
      const autoGenerated = !draftName;
      const finalDraftName = draftName || this.generateAutoSaveName('Meal Plan');
      
      const draft = {
        id: `mealPlan_${timestamp}`,
        name: finalDraftName,
        data: mealPlanData,
        timestamp,
        autoGenerated,
        source: options.source || 'user_edit',
        dayCount: mealPlanData.length,
        recipeCount: this.countRecipesInMealPlan(mealPlanData),
        version: '2.0' // Track data format version
      };

      // Get existing drafts
      const existingDrafts = await this.getMealPlanDrafts();
      
      // Add new draft and limit to MAX_DRAFTS_PER_TYPE
      const updatedDrafts = [draft, ...existingDrafts].slice(0, this.MAX_DRAFTS_PER_TYPE);
      
      await AsyncStorage.setItem('mealPlanDrafts', JSON.stringify(updatedDrafts));
      
      console.log(`ğŸ“ Meal plan draft saved: "${finalDraftName}" (${draft.recipeCount} recipes)`);
      
      // Mark as saved (no unsaved changes)
      this.setUnsavedChanges('mealPlan_current', false);
      
      return {
        success: true,
        draftId: draft.id,
        draftName: finalDraftName
      };
      
    } catch (error) {
      console.error('âŒ Save meal plan draft failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Load all meal plan drafts
   */
  async getMealPlanDrafts() {
    try {
      const drafts = await AsyncStorage.getItem('mealPlanDrafts');
      return drafts ? JSON.parse(drafts) : [];
    } catch (error) {
      console.error('âŒ Load meal plan drafts failed:', error);
      return [];
    }
  }

  /**
   * Load a specific meal plan draft by ID
   */
  async loadMealPlanDraft(draftId) {
    try {
      const drafts = await this.getMealPlanDrafts();
      const draft = drafts.find(d => d.id === draftId);
      
      if (draft) {
        console.log(`ğŸ“– Loaded meal plan draft: "${draft.name}"`);
        return { success: true, data: draft.data, meta: draft };
      } else {
        return { success: false, error: 'Draft not found' };
      }
    } catch (error) {
      console.error('âŒ Load meal plan draft failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Delete a meal plan draft
   */
  async deleteMealPlanDraft(draftId) {
    try {
      const drafts = await this.getMealPlanDrafts();
      const updatedDrafts = drafts.filter(d => d.id !== draftId);
      
      await AsyncStorage.setItem('mealPlanDrafts', JSON.stringify(updatedDrafts));
      console.log(`ğŸ—‘ï¸ Deleted meal plan draft: ${draftId}`);
      
      return { success: true };
    } catch (error) {
      console.error('âŒ Delete meal plan draft failed:', error);
      return { success: false, error: error.message };
    }
  }

  // ==============================================
  // ğŸ›’ GROCERY LIST DRAFT MANAGEMENT
  // ==============================================

  /**
   * Save a grocery list draft with timestamp
   */
  async saveGroceryListDraft(groceryData, draftName = null, options = {}) {
    try {
      const timestamp = Date.now();
      const autoGenerated = !draftName;
      const finalDraftName = draftName || this.generateAutoSaveName('Grocery List');
      
      const draft = {
        id: `groceryList_${timestamp}`,
        name: finalDraftName,
        data: groceryData,
        timestamp,
        autoGenerated,
        source: options.source || 'user_edit',
        itemCount: groceryData.items?.length || 0,
        version: '2.0'
      };

      const existingDrafts = await this.getGroceryListDrafts();
      const updatedDrafts = [draft, ...existingDrafts].slice(0, this.MAX_DRAFTS_PER_TYPE);
      
      await AsyncStorage.setItem('groceryListDrafts', JSON.stringify(updatedDrafts));
      
      console.log(`ğŸ›’ Grocery list draft saved: "${finalDraftName}" (${draft.itemCount} items)`);
      
      this.setUnsavedChanges('groceryList_current', false);
      
      return {
        success: true,
        draftId: draft.id,
        draftName: finalDraftName
      };
      
    } catch (error) {
      console.error('âŒ Save grocery list draft failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Load all grocery list drafts
   */
  async getGroceryListDrafts() {
    try {
      const drafts = await AsyncStorage.getItem('groceryListDrafts');
      return drafts ? JSON.parse(drafts) : [];
    } catch (error) {
      console.error('âŒ Load grocery list drafts failed:', error);
      return [];
    }
  }

  /**
   * Load a specific grocery list draft by ID
   */
  async loadGroceryListDraft(draftId) {
    try {
      const drafts = await this.getGroceryListDrafts();
      const draft = drafts.find(d => d.id === draftId);
      
      if (draft) {
        console.log(`ğŸ›’ Loaded grocery list draft: "${draft.name}"`);
        return { success: true, data: draft.data, meta: draft };
      } else {
        return { success: false, error: 'Draft not found' };
      }
    } catch (error) {
      console.error('âŒ Load grocery list draft failed:', error);
      return { success: false, error: error.message };
    }
  }

  // ==============================================
  // ğŸ”„ CROSS-FEATURE INTEGRATION
  // ==============================================

  /**
   * Generate grocery list from meal plan data
   */
  async generateGroceryListFromMealPlan(mealPlanData, options = {}) {
    try {
      console.log('ğŸ”„ Generating grocery list from meal plan data');
      
      // Extract all recipes from all days
      const allRecipes = [];
      mealPlanData.forEach(day => {
        if (day.recipes && Array.isArray(day.recipes)) {
          allRecipes.push(...day.recipes);
        }
        
        // Also check meals structure for compatibility
        if (day.meals && Array.isArray(day.meals)) {
          day.meals.forEach(meal => {
            if (meal.recipes && Array.isArray(meal.recipes)) {
              allRecipes.push(...meal.recipes);
            }
          });
        }
      });

      // Create basic grocery list structure
      // Note: This is a simplified version - in production, you'd want to
      // integrate with recipe ingredient extraction or use the backend API
      const groceryItems = allRecipes.map((recipe, index) => ({
        id: `item_${Date.now()}_${index}`,
        name: `Ingredients for ${recipe.title || recipe.name}`,
        isCompleted: false,
        source: 'meal_plan_generation',
        recipeId: recipe.id,
        recipeTitle: recipe.title || recipe.name
      }));

      const groceryListData = {
        title: options.title || `Grocery List - ${new Date().toLocaleDateString()}`,
        items: groceryItems,
        generatedFrom: 'meal_plan',
        sourceData: {
          mealPlanRecipeCount: allRecipes.length,
          generatedAt: Date.now()
        }
      };

      // Save as draft automatically
      const saveResult = await this.saveGroceryListDraft(
        groceryListData,
        groceryListData.title,
        { source: 'meal_plan_generation' }
      );

      console.log(`âœ… Generated grocery list with ${groceryItems.length} items`);
      
      return {
        success: true,
        groceryListData,
        draftId: saveResult.draftId,
        itemCount: groceryItems.length
      };
      
    } catch (error) {
      console.error('âŒ Generate grocery list from meal plan failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Create a temporary backup before loading cloud data
   */
  async createTempBackup(type, currentData, backupName = null) {
    try {
      const timestamp = Date.now();
      const finalBackupName = backupName || `Backup before load - ${new Date().toLocaleTimeString()}`;
      
      if (type === 'mealPlan') {
        return await this.saveMealPlanDraft(currentData, finalBackupName, { source: 'temp_backup' });
      } else if (type === 'groceryList') {
        return await this.saveGroceryListDraft(currentData, finalBackupName, { source: 'temp_backup' });
      }
      
      return { success: false, error: 'Unknown backup type' };
      
    } catch (error) {
      console.error('âŒ Create temp backup failed:', error);
      return { success: false, error: error.message };
    }
  }

  // ==============================================
  // ğŸ¯ AUTO-SAVE SYSTEM
  // ==============================================

  /**
   * Start auto-save timer for a data type
   */
  startAutoSave(dataType, saveCallback) {
    this.stopAutoSave(dataType); // Clear existing timer
    
    const timerId = setInterval(() => {
      if (this.hasUnsavedChanges(dataType)) {
        console.log(`â° Auto-save triggered for ${dataType}`);
        saveCallback();
      }
    }, this.AUTO_SAVE_INTERVAL);
    
    this.autoSaveTimers.set(dataType, timerId);
    console.log(`ğŸ”„ Auto-save started for ${dataType} (${this.AUTO_SAVE_INTERVAL / 1000}s interval)`);
  }

  /**
   * Stop auto-save timer for a data type
   */
  stopAutoSave(dataType) {
    const timerId = this.autoSaveTimers.get(dataType);
    if (timerId) {
      clearInterval(timerId);
      this.autoSaveTimers.delete(dataType);
      console.log(`â¹ï¸ Auto-save stopped for ${dataType}`);
    }
  }

  /**
   * Mark data as having unsaved changes
   */
  setUnsavedChanges(dataType, hasChanges) {
    this.unsavedChanges.set(dataType, hasChanges);
    console.log(`ğŸ“ Unsaved changes ${hasChanges ? 'marked' : 'cleared'} for ${dataType}`);
  }

  /**
   * Check if data type has unsaved changes
   */
  hasUnsavedChanges(dataType) {
    return this.unsavedChanges.get(dataType) || false;
  }

  // ==============================================
  // ğŸ› ï¸ UTILITY METHODS
  // ==============================================

  /**
   * Generate auto-save name with timestamp
   */
  generateAutoSaveName(baseName) {
    const now = new Date();
    const time = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const date = now.toLocaleDateString();
    return `${baseName} - ${date} ${time}`;
  }

  /**
   * Count recipes in meal plan data
   */
  countRecipesInMealPlan(mealPlanData) {
    let count = 0;
    mealPlanData.forEach(day => {
      if (day.recipes && Array.isArray(day.recipes)) {
        count += day.recipes.length;
      }
      if (day.meals && Array.isArray(day.meals)) {
        day.meals.forEach(meal => {
          if (meal.recipes && Array.isArray(meal.recipes)) {
            count += meal.recipes.length;
          }
        });
      }
    });
    return count;
  }

  /**
   * Clean up old drafts and free storage space
   */
  async cleanupOldDrafts(daysToKeep = 7) {
    try {
      const cutoffTime = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);
      
      // Clean meal plan drafts
      const mealPlanDrafts = await this.getMealPlanDrafts();
      const filteredMealPlanDrafts = mealPlanDrafts.filter(draft => 
        draft.timestamp > cutoffTime || !draft.autoGenerated
      );
      
      // Clean grocery list drafts
      const groceryListDrafts = await this.getGroceryListDrafts();
      const filteredGroceryListDrafts = groceryListDrafts.filter(draft => 
        draft.timestamp > cutoffTime || !draft.autoGenerated
      );
      
      await AsyncStorage.setItem('mealPlanDrafts', JSON.stringify(filteredMealPlanDrafts));
      await AsyncStorage.setItem('groceryListDrafts', JSON.stringify(filteredGroceryListDrafts));
      
      const cleanedCount = (mealPlanDrafts.length - filteredMealPlanDrafts.length) + 
                          (groceryListDrafts.length - filteredGroceryListDrafts.length);
      
      if (cleanedCount > 0) {
        console.log(`ğŸ§¹ Cleaned up ${cleanedCount} old drafts`);
      }
      
      return { success: true, cleanedCount };
      
    } catch (error) {
      console.error('âŒ Cleanup old drafts failed:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get storage usage statistics
   */
  async getStorageStats() {
    try {
      const mealPlanDrafts = await this.getMealPlanDrafts();
      const groceryListDrafts = await this.getGroceryListDrafts();
      
      return {
        mealPlanDrafts: {
          count: mealPlanDrafts.length,
          autoSaves: mealPlanDrafts.filter(d => d.autoGenerated).length,
          userSaves: mealPlanDrafts.filter(d => !d.autoGenerated).length
        },
        groceryListDrafts: {
          count: groceryListDrafts.length,
          autoSaves: groceryListDrafts.filter(d => d.autoGenerated).length,
          userSaves: groceryListDrafts.filter(d => !d.autoGenerated).length
        },
        totalDrafts: mealPlanDrafts.length + groceryListDrafts.length
      };
    } catch (error) {
      console.error('âŒ Get storage stats failed:', error);
      return null;
    }
  }

  // ==============================================
  // ğŸ”„ TRIGGER METHODS (Called by screens)
  // ==============================================

  async triggerMealPlanAutoSave(dataKey) {
    // To be implemented when integrating with MealPlanScreen
    console.log(`ğŸ”„ Meal plan auto-save triggered for ${dataKey}`);
  }

  async triggerGroceryListAutoSave(dataKey) {
    // To be implemented when integrating with GroceryListScreen
    console.log(`ğŸ›’ Grocery list auto-save triggered for ${dataKey}`);
  }

  // ==============================================
  // ğŸ—‘ï¸ CLEANUP
  // ==============================================

  /**
   * Clean up timers when service is destroyed
   */
  cleanup() {
    // Clear all auto-save timers
    for (const timerId of this.autoSaveTimers.values()) {
      clearInterval(timerId);
    }
    this.autoSaveTimers.clear();
    
    // Remove app state listener
    AppState.removeEventListener('change', this.handleAppStateChange);
    
    console.log('ğŸ§¹ LocalDataManager cleanup completed');
  }
}

// Create singleton instance
const localDataManager = new LocalDataManager();

export default localDataManager;